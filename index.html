<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Scratch Reveal - Gender</title>
<style>
  :root{ --w:260px; --h:120px; }

  body {
    display:flex;
    align-items:center;
    justify-content:center;
    height:100vh;
    margin:0;
    background:#f3f3f3;
    font-family:system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;
  }

  .card {
    width:360px;
    background:#fff;
    border-radius:12px;
    box-shadow:0 10px 30px rgba(0,0,0,.08);
    display:flex;
    flex-direction:column;
    align-items:center;
    padding:20px;
    gap:12px;
  }

  h1{ margin:0; font-size:16px; color:#222; text-align:center; }
  p{ margin:0; color:#666; font-size:14px; text-align:center; }

  /* zone de grattage */
  .scratch-area {
    position:relative;
    width:var(--w);
    height:var(--h);
    border-radius:10px;
    overflow:hidden;
    background: linear-gradient(180deg,#fff,#fff); /* couleur sous-jacente */
    display:block;
  }

  /* texte centr√© sous le masque */
  #result{
    position:absolute;
    inset:0;               /* top:0;right:0;bottom:0;left:0; */
    display:flex;
    align-items:center;
    justify-content:center;
    text-align:center;
    font-weight:700;
    font-size:20px;
    z-index:1;            /* sous le canvas (canvas z-index:2) */
    pointer-events:none;  /* laisse passer les events vers le canvas */
    padding:8px;
  }

  /* canvas couvrant exactement la zone */
  canvas#scratch{
    position:absolute;
    left:0;
    top:0;
    width:100%;
    height:100%;
    z-index:2;
    display:block;
    border-radius:10px;
    touch-action:none;
  }

  .controls{ margin-top:8px; display:flex; gap:8px; flex-wrap:wrap; justify-content:center; }
  button{
    padding:8px 10px;
    border-radius:8px;
    border:1px solid #e0e0e0;
    background:#fafafa;
    cursor:pointer;
    font-size:13px;
  }

  /* petit feedback quand r√©v√©l√© */
  .revealed { transition: transform .22s ease, opacity .22s ease; transform:scale(1.02); }
</style>
</head>
<body>
  <div class="card">
    <h1>Ptite fille ou Ptit Gar√ßon ?! (gratte en dessous)</h1>
    <p id="hint">Gratte la zone grise pour r√©v√©ler le sexe.</p>

    <div class="scratch-area" aria-hidden="false">
      <div id="result">üéâ‚ú®C'est une fille!üå∑üéÄ</div>
      <canvas id="scratch" width="260" height="120"></canvas>
    </div>

    <div class="controls">
      <button id="reset">R√©initialiser</button>
      <button id="setBoy">Mettre gar√ßon</button>
      <button id="setGirl">Mettre fille</button>
      <button id="download">T√©l√©charger image</button>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('scratch');
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  const result = document.getElementById('result');
  const hint = document.getElementById('hint');

  let drawing = false;
  let dpr = window.devicePixelRatio || 1;

  // adapte le canvas au CSS size en tenant compte du devicePixelRatio
  function resizeCanvas() {
    dpr = window.devicePixelRatio || 1;
    const wCSS = Math.round(canvas.clientWidth);
    const hCSS = Math.round(canvas.clientHeight);
    canvas.width = Math.round(wCSS * dpr);
    canvas.height = Math.round(hCSS * dpr);
    // fait en sorte que les op√©rations de dessin utilisent des "CSS pixels"
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    // (re)remplit le masque
    fillMask();
  }

  // remplit le masque (papier √† gratter)
  function fillMask() {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    // mise √† z√©ro propre
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // base en source-over
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;

    const g = ctx.createLinearGradient(0,0,w,h);
    g.addColorStop(0,'#bdbdbd');
    g.addColorStop(1,'#9a9a9a');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // l√©g√®re texture
    ctx.fillStyle = '#000';
    for (let i=0; i<220; i++){
      ctx.globalAlpha = 0.03;
      ctx.fillRect(Math.random()*w, Math.random()*h, Math.random()*3+1, Math.random()*3+1);
    }
    ctx.globalAlpha = 1;

    // pr√©pare l'effacement par traits
    ctx.globalCompositeOperation = 'destination-out';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.lineWidth = 30; // en CSS pixels (transform g√©r√© plus haut)
  }

  // gestion du dessin (effacement)
  function pointerDown(e){
    drawing = true;
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX ?? (e.touches && e.touches[0].clientX)) - rect.left;
    const y = (e.clientY ?? (e.touches && e.touches[0].clientY)) - rect.top;
    ctx.beginPath();
    ctx.moveTo(x, y);
    // capture (si pointer events)
    if (e.pointerId) canvas.setPointerCapture && canvas.setPointerCapture(e.pointerId);
    // trace initial finement
    ctx.lineTo(x, y);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x, y);
  }

  function pointerMove(e){
    if (!drawing) return;
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX ?? (e.touches && e.touches[0].clientX)) - rect.left;
    const y = (e.clientY ?? (e.touches && e.touches[0].clientY)) - rect.top;
    ctx.lineTo(x, y);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x, y);
  }

  function pointerUp(e){
    drawing = false;
    ctx.beginPath();
    if (e && e.pointerId) canvas.releasePointerCapture && canvas.releasePointerCapture(e.pointerId);
    checkReveal();
  }

  // calcule la proportion effac√©e et d√©clenche r√©v√©lation
  function checkReveal(){
    // on lit en pixels physiques (canvas.width/height)
    const img = ctx.getImageData(0,0,canvas.width,canvas.height).data;
    let cleared = 0;
    // on consid√®re effac√© si alpha === 0 (transparent)
    for (let i=3; i<img.length; i+=4){
      if (img[i] === 0) cleared++;
    }
    const ratio = cleared / (canvas.width * canvas.height);
    if (ratio > 0.45) {
      // efface enti√®rement le masque (en CSS pixels)
      ctx.setTransform(dpr,0,0,dpr,0,0); // s'assurer du transform
      ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);
      hint.textContent = 'R√©v√©l√© !';
      result.classList.add('revealed');
    }
  }

  // events pointer (prend en charge souris + touch si le navigateur supporte PointerEvent)
  canvas.addEventListener('pointerdown', pointerDown);
  canvas.addEventListener('pointermove', pointerMove);
  window.addEventListener('pointerup', pointerUp);
  window.addEventListener('pointercancel', pointerUp);

  // touch fallback si n√©cessaire (surtout vieux navigateurs)
  canvas.addEventListener('touchstart', function(e){ e.preventDefault(); pointerDown(e); }, {passive:false});
  canvas.addEventListener('touchmove', function(e){ e.preventDefault(); pointerMove(e); }, {passive:false});
  canvas.addEventListener('touchend', function(e){ e.preventDefault(); pointerUp(e); }, {passive:false});

  // controls
  document.getElementById('reset').addEventListener('click', () => {
    result.classList.remove('revealed');
    hint.textContent = 'Gratte la zone grise pour r√©v√©ler le sexe.';
    fillMask();
  });

  document.getElementById('setBoy').addEventListener('click', () => {
    result.innerHTML = 'üéâ C\'est un gar√ßon ! üíô';
    result.classList.remove('revealed');
    fillMask();
  });

  document.getElementById('setGirl').addEventListener('click', () => {
    result.innerHTML = 'üéâ C\'est une fille ! üéÄ';
    result.classList.remove('revealed');
    fillMask();
  });

  document.getElementById('download').addEventListener('click', () => {
    // cr√©e une image combin√©e (texte + √©tat du masque)
    const off = document.createElement('canvas');
    off.width = 600;
    off.height = 360;
    const octx = off.getContext('2d');

    // fond blanc + texte centr√©
    octx.fillStyle = '#fff';
    octx.fillRect(0,0,off.width,off.height);
    octx.textAlign = 'center';
    octx.font = '28px sans-serif';
    octx.fillStyle = '#333';
    octx.fillText(result.textContent, off.width/2, off.height/2);

    // copie l'√©tat actuel du canvas (redimensionne pour placer au centre)
    const sx = (off.width - canvas.clientWidth)/2;
    const sy = (off.height - canvas.clientHeight)/2;
    octx.drawImage(canvas, sx, sy, canvas.clientWidth, canvas.clientHeight);

    const a = document.createElement('a');
    a.href = off.toDataURL('image/png');
    a.download = 'gender-reveal.png';
    a.click();
  });

  // redimensionne au chargement / redimensionnement de la fen√™tre
  window.addEventListener('resize', resizeCanvas);

  // initialisation
  // s'assurer que le canvas a ses dimensions CSS correctes (utile si le navigateur calcule avant que CSS soit appliqu√©)
  requestAnimationFrame(resizeCanvas);
})();
</script>
</body>
</html>
