<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Scratch Reveal - Gender</title>
<style>
  :root{ --w:260px; --h:120px; }

  body {
    display:flex;
    align-items:center;
    justify-content:center;
    height:100vh;
    margin:0;
    background:#f3f3f3;
    font-family:system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;
  }

  .card {
    width:360px;
    background:#fff;
    border-radius:12px;
    box-shadow:0 10px 30px rgba(0,0,0,.08);
    display:flex;
    flex-direction:column;
    align-items:center;
    padding:20px;
    gap:12px;
  }

  h1{ margin:0; font-size:16px; color:#222; text-align:center; }
  p{ margin:0; color:#666; font-size:14px; text-align:center; }

  /* zone de grattage */
  .scratch-area {
    position:relative;
    width:var(--w);
    height:var(--h);
    border-radius:10px;
    overflow:hidden;
    background: linear-gradient(180deg,#fff,#fff);
    display:block;
  }

  /* texte centr√© sous le masque */
  #result{
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    text-align:center;
    font-weight:700;
    font-size:20px;
    z-index:1;
    pointer-events:none;
    padding:8px;
  }

  /* canvas couvrant exactement la zone */
  canvas#scratch{
    position:absolute;
    left:0;
    top:0;
    width:100%;
    height:100%;
    z-index:2;
    display:block;
    border-radius:10px;
    touch-action:none;
  }

  /* petit feedback quand r√©v√©l√© */
  .revealed { transition: transform .22s ease, opacity .22s ease; transform:scale(1.02); }
</style>
</head>
<body>
  <div class="card">
    <h1>Ptite fille ou Ptit Gar√ßon ?! (gratte en dessous)</h1>
    <p id="hint">Gratte la zone grise pour r√©v√©ler le sexe.</p>

    <div class="scratch-area" aria-hidden="false">
      <div id="result">üéâ‚ú®C'est une fille!üå∑üéÄ</div>
      <canvas id="scratch" width="260" height="120"></canvas>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('scratch');
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  const result = document.getElementById('result');
  const hint = document.getElementById('hint');

  let drawing = false;
  let dpr = window.devicePixelRatio || 1;

  function resizeCanvas() {
    dpr = window.devicePixelRatio || 1;
    const wCSS = Math.round(canvas.clientWidth);
    const hCSS = Math.round(canvas.clientHeight);
    canvas.width = Math.round(wCSS * dpr);
    canvas.height = Math.round(hCSS * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    fillMask();
  }

  function fillMask() {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    ctx.clearRect(0,0,canvas.width,canvas.height);

    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;

    const g = ctx.createLinearGradient(0,0,w,h);
    g.addColorStop(0,'#bdbdbd');
    g.addColorStop(1,'#9a9a9a');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    ctx.fillStyle = '#000';
    for (let i=0; i<220; i++){
      ctx.globalAlpha = 0.03;
      ctx.fillRect(Math.random()*w, Math.random()*h, Math.random()*3+1, Math.random()*3+1);
    }
    ctx.globalAlpha = 1;

    ctx.globalCompositeOperation = 'destination-out';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.lineWidth = 30;
  }

  function pointerDown(e){
    drawing = true;
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX ?? (e.touches && e.touches[0].clientX)) - rect.left;
    const y = (e.clientY ?? (e.touches && e.touches[0].clientY)) - rect.top;
    ctx.beginPath();
    ctx.moveTo(x, y);
    if (e.pointerId) canvas.setPointerCapture && canvas.setPointerCapture(e.pointerId);
    ctx.lineTo(x, y);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x, y);
  }

  function pointerMove(e){
    if (!drawing) return;
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX ?? (e.touches && e.touches[0].clientX)) - rect.left;
    const y = (e.clientY ?? (e.touches && e.touches[0].clientY)) - rect.top;
    ctx.lineTo(x, y);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x, y);
  }

  function pointerUp(e){
    drawing = false;
    ctx.beginPath();
    if (e && e.pointerId) canvas.releasePointerCapture && canvas.releasePointerCapture(e.pointerId);
    checkReveal();
  }

  function checkReveal(){
    const img = ctx.getImageData(0,0,canvas.width,canvas.height).data;
    let cleared = 0;
    for (let i=3; i<img.length; i+=4){
      if (img[i] === 0) cleared++;
    }
    const ratio = cleared / (canvas.width * canvas.height);
    if (ratio > 0.45) {
      ctx.setTransform(dpr,0,0,dpr,0,0);
      ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);
      hint.textContent = 'R√©v√©l√© !';
      result.classList.add('revealed');
    }
  }

  canvas.addEventListener('pointerdown', pointerDown);
  canvas.addEventListener('pointermove', pointerMove);
  window.addEventListener('pointerup', pointerUp);
  window.addEventListener('pointercancel', pointerUp);

  canvas.addEventListener('touchstart', function(e){ e.preventDefault(); pointerDown(e); }, {passive:false});
  canvas.addEventListener('touchmove', function(e){ e.preventDefault(); pointerMove(e); }, {passive:false});
  canvas.addEventListener('touchend', function(e){ e.preventDefault(); pointerUp(e); }, {passive:false});

  window.addEventListener('resize', resizeCanvas);
  requestAnimationFrame(resizeCanvas);
})();
</script>
</body>
</html>
